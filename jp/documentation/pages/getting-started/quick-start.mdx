---
title: "30分間クイックスタート"
description: "サンプルアプリを通じてDifyを深く理解"
icon: "forward"
---

このステップバイステップのチュートリアルでは、ゼロからマルチプラットフォームコンテンツジェネレーターを作成します。

基本的なLLM統合を超えて、強力なDifyノードを使用して、より速く、より簡単に洗練されたAIアプリケーションを構築する方法を発見します。

このチュートリアルの終わりまでに、あなたが投げかけるあらゆるコンテンツ（テキスト、ドキュメント、画像）を取り込み、好みの音声とトーンを追加し、選択した言語で洗練されたプラットフォーム固有のソーシャルメディア投稿を生成するワークフローを作成します。

完全なワークフローを以下に示します。構築中はいつでも参照して、軌道に乗っていることを確認し、すべてのノードがどのように連携するかを確認してください。

<img
  src="/images/deeper_dive_workflow_overview.png"
  alt="クイックスタートワークフロー概要"
  title="クイックスタートワークフロー概要"
  className="mx-auto"
/>

## ステップ1：新しいワークフローの作成

1. **Studio**に移動し、**空白から作成** \> **ワークフロー**を選択します。
2. ワークフローに`マルチプラットフォームコンテンツジェネレーター`という名前を付けて、**作成**をクリックします。自動的にワークフローキャンバスに移動し、構築を開始します。

## ステップ2：ワークフローノードの追加と設定

<Note>
  言及されていない設定はデフォルト値のままにしてください。
</Note>

<Tip>
  ノードと変数に明確で説明的な名前を付けて、ワークフロー内で識別と参照が簡単になるようにします。
</Tip>

### 1. スタートノード：ユーザー入力の収集

<Info>
  まず、ドラフトテキスト、ターゲットプラットフォーム、希望のトーン、参考資料など、ユーザーから収集する情報を定義する必要があります。

  スタートノードは、これらを簡単に設定できる場所です。ここに追加する各入力フィールドは、すべての下流ノードが参照して使用できる変数になります。
</Info>

<img
  src="/images/deeper_dive_start.png"
  alt="スタートノード"
  title="スタートノード"
  className="mx-auto"
  style={{ width:"71%" }}
/>

スタートノード（**\+**ではない）をクリックして設定パネルを開き、次の入力フィールドを追加します。

<Accordion title="参考資料 - テキスト">
  - フィールドタイプ：`段落`
  - 変数名：`draft`
  - ラベル名：`ドラフト`
  - 最大長：`2048`
  - 必須：`いいえ`
</Accordion>

<Accordion title="参考資料 - ファイル">
  - フィールドタイプ：`ファイルリスト`
  - 変数名：`user_file`
  - ラベル名：`ファイルをアップロード (≤ 10)`
  - サポートファイルタイプ：`ドキュメント`、`画像`
  - アップロードファイルタイプ：`両方`
  - 最大アップロード数：`10`
  - 必須：`いいえ`
</Accordion>

<Accordion title="ボイスとトーン">
  - フィールドタイプ：`段落`
  - 変数名：`voice_and_tone`
  - ラベル名：`ボイス＆トーン`
  - 最大長：`2048`
  - 必須：`いいえ`
</Accordion>

<Accordion title="ターゲットプラットフォーム">
  - フィールドタイプ：`短いテキスト`
  - 変数名：`platform`
  - ラベル名：`ターゲットプラットフォーム (≤ 10)`
  - 最大長：`256`
  - 必須：`はい`
</Accordion>

<Accordion title="言語要件">
  - フィールドタイプ：`選択`
  - 変数名：`language`
  - ラベル名：`言語`
  - オプション：
    - `English`
    - `日本語`
    - `简体中文`
  - デフォルト値：`English`
  - 必須：`はい`
</Accordion>

### 2. パラメータ抽出器ノード：ターゲットプラットフォームの識別

<Info>
  プラットフォームフィールドは自由形式のテキスト入力を受け入れるため、ユーザーは様々な方法で入力する可能性があります：`x and linkedIn`、`post on Twitter and LinkedIn`、さらには`Twitter + LinkedIn please`など。しかし、下流ノードが確実に動作できる`["Twitter", "LinkedIn"]`のようなクリーンで構造化されたリストが必要です。

  これはパラメータ抽出器ノードの完璧な仕事です。LLMを使用してユーザーの自然言語を分析し、これらすべてのバリエーションを認識し、標準化された配列を出力します。
</Info>

<img
  src="/images/deeper_dive_paramater_extractor.png"
  alt="パラメータ抽出器"
  title="パラメータ抽出器"
  className="mx-auto"
  style={{ width:"73%" }}
/>

スタートノードの後に、パラメータ抽出器ノードを追加して設定します：

1. モデルを選択します。
2. `Start/platform`を入力変数として設定します。
3. 抽出パラメータを追加します：
   1. 名前：`platform`
   2. タイプ：`Array[String]`
   3. 説明：`ユーザーがカスタマイズされたコンテンツを作成したいプラットフォームを識別して抽出します。`
   4. 必須：`はい`
4. 指示フィールドに、LLMのパラメータ抽出をガイドする以下を貼り付けます：

   ```markdown 指示
   # タスク説明
   入力からプラットフォーム名を解析し、JSON配列として出力します。

   ## 処理ルール
   - 複数の区切り文字をサポート：カンマ、セミコロン、スペース、改行、"and"、"&"、"|"など。
   - 一般的なプラットフォーム名のバリアントを標準化（twitter/X→Twitter、insta→Instagramなど）。
   - 重複と無効なエントリを削除
   - 未知だが合理的なプラットフォーム名を保持

   ## 出力要件
   - 成功：["Platform1", "Platform2"]
   - プラットフォームが見つからない：[プラットフォームが識別されませんでした。有効なプラットフォーム名を入力してください。]

   ## 例
   - 入力："twitter, linkedin" → ["Twitter", "LinkedIn"]
   - 入力："x and insta" → ["Twitter", "Instagram"]
   - 入力："invalid content" → [プラットフォームが識別されませんでした。有効なプラットフォーム名を入力してください。]
   ```

   <Check>
     無効な入力に対して特定のエラーメッセージを出力するようLLMに指示したことに注意してください。これは次のステップでワークフローの終了トリガーとして機能します。
   </Check>

### 3. IF/ELSEノード：プラットフォーム抽出結果の検証

<Info>
  ユーザーが`ohhhhhh`や`BookFace`のような無効なプラットフォーム名を入力した場合はどうなるでしょうか？無駄なコンテンツを生成するために時間とトークンを無駄にしたくありません。

  そのような場合、IF/ELSEノードを使用してワークフローを早期に停止する分岐を作成できます。パラメータ抽出器ノードからのエラーメッセージをチェックする条件を設定し、そのメッセージが検出された場合、ワークフローは直接終了ノードにルーティングされます。
</Info>

<img
  src="/images/deeper_dive_if.png"
  alt="If条件"
  className="mx-auto"
  style={{ width:"80%" }}
  title="If条件"
/>

1. パラメータ抽出器ノードの後に、IF/ELSEノードを追加します。
2. IF/ELSEノードのパネルで、IF条件を定義します：

   **IF** `Parameter Extractor/platform` `含む` `プラットフォームが識別されませんでした。有効なプラットフォーム名を入力してください。`
3. IF/ELSEノードの後、IFブランチに終了ノードを追加します。
4. 終了ノードのパネルで、`Parameter Extractor/platform`を出力変数として設定します。

### 4. リスト演算子ノード：アップロードされたファイルをタイプ別に分離

<Info>
  ユーザーは参考資料として画像とドキュメントの両方をアップロードできますが、この2つのタイプは異なる処理が必要です：画像はビジョン対応モデルで直接解釈できますが、ドキュメントはまずLLMがコンテンツを理解できるようにテキストに変換する必要があります。

  これを管理するために、2つのリスト演算子ノードを使用して、アップロードされたファイルをフィルタリングし、別々のブランチに分割します—1つは画像用、1つはドキュメント用です。
</Info>

<img
  src="/images/deeper_dive_list_operator.png"
  alt="リスト演算子"
  className="mx-auto"
  style={{ width:"70%" }}
  title="リスト演算子"
/>

1. IF/ELSEノードの後、ELSEブランチに2つのリスト演算子ノードを追加します。
2. 1つのノードを`画像`、もう1つを`ドキュメント`に名前を変更します。
3. 画像ノードを設定します：
   1. `Start/user_file`を入力変数として設定します。
   2. フィルタ条件を有効にします：`{x}type` `に` `Image`
4. ドキュメントノードを設定します：
   1. `Start/user_file`を入力変数として設定します。
   2. フィルタ条件を有効にします：`{x}type` `に` `Doc`。

### 5. ドキュメント抽出器ノード：ドキュメントからテキストを抽出

<Info>
  LLMはPDFやDOCXなどのアップロードされたファイルを直接読むことはできません。これらのドキュメントの情報を使用するには、まずLLMが処理できるプレーンテキストに変換する必要があります。

  これがまさにドキュメント抽出器ノードが行うことです。ドキュメントファイルを入力として受け取り、次のステップのためにクリーンで使用可能なテキストを出力します。
</Info>

1. ドキュメントノードの後に、ドキュメント抽出器ノードを追加します。
2. ドキュメント抽出器ノードのパネルで、`Document/result`を入力変数として設定します。

### 6. LLMノード：すべての参考資料を統合

<Info>
  ユーザーが複数の参考タイプ—ドラフトテキスト、ドキュメント、画像—を同時に提供する場合、それらを一つのまとまった要約に統合する必要があります。

  LLMノードは、すべての散在する部分を分析してこのタスクを処理し、後続のコンテンツ生成をガイドする包括的なコンテキストを作成します。
</Info>

<img
  src="/images/deeper_dive_info_integrate.png"
  alt="情報統合"
  className="mx-auto"
  style={{ width:"78%" }}
  title="情報統合"
/>

1. ドキュメント抽出器ノードの後に、LLMノードを追加します。
2. 画像ノードもこのLLMノードに接続します。
3. LLMノードをクリックして設定します：
   1. `情報統合`に名前を変更します。
   2. ビジョンをサポートするモデル（目のアイコンで示される）を選択します。
   3. **ビジョン**を有効にし、`Image/result`をビジョン変数として設定します。
   4. システムプロンプトフィールドに、以下を貼り付けます：

      <Warning>
        プロンプトで、_提供された材料_の`Doc Extractor/text`と`Start/draft`変数を参照するには、`{`または`/`を入力してリストから選択します。

        <img
          src="/images/deeper_dive_reference_variable.png"
          alt="変数を参照"
          title="変数を参照"
          className="mx-auto"
          style={{ width:"58%" }}
        />
      </Warning>
      ```markdown システム {2,3}
      # 提供された材料
      Doc Extractor/text
      Start/draft

      # 役割とタスク
      あなたはコンテンツストラテジストです。提供された資料を分析し、マルチプラットフォームソーシャルメディア最適化のための包括的なコンテンツ基盤を作成します。

      # 分析原則
      - 提供された情報のみで作業—外部の仮定なし
      - 抽出、統合、戦略的解釈に焦点を当てる
      - 説得力のある実用的な要素を特定
      - 異なるプラットフォーム間で適応可能な洞察を準備

      # 必要な分析
      構造化された分析を提供：

      ## 1. コアメッセージ
      - 中心テーマ、目的、目標
      - 伝えられる主要な価値または利益

      ## 2. 必須コンテンツ要素
      - 主要トピック、事実、統計、データポイント
      - 注目すべき引用、証言、キーステートメント
      - 言及された機能、利点、特徴
      - 日付、場所、文脈の詳細

      ## 3. 戦略的洞察
      - コンテンツを説得力のある/ユニークにするもの
      - 存在する感情的/理性的アピール
      - 信頼性要因、証明ポイント
      - 強調された競争優位性

      ## 4. エンゲージメントの機会
      - 出現する議論ポイント、質問
      - 提案されたコール・トゥ・アクション、次のステップ
      - インタラクティブ/参加の機会
      - 触れられたトレンディングテーマ

      ## 5. プラットフォーム最適化の基盤
      - 高インパクト：クイックで共有可能な形式
      - プロフェッショナル：ビジネス中心のディスカッション
      - コミュニティ：インタラクションと共有
      - ビジュアル：強力なビジュアルで強化

      ## 6. サポート詳細
      - メトリクス、数値、定量化可能な結果
      - 直接引用、証言
      - 技術的詳細、仕様
      - 利用可能な背景コンテキスト
      ```

### 7. イテレーションノード：各プラットフォーム向けにカスタマイズされたコンテンツを作成

<Info>
  統合された参照とターゲットプラットフォームの準備ができたので、イテレーションノードを使用して各プラットフォーム向けにカスタマイズされた投稿を生成しましょう。

  このノードはプラットフォームのリストをループし、各プラットフォーム用のサブワークフローを実行します：まず特定のプラットフォームのスタイルガイドラインとベストプラクティスを分析し、次に利用可能なすべての情報に基づいて最適化されたコンテンツを生成します。
</Info>

<img
  src="/images/deeper_dive_integration.png"
  alt="イテレーションノード"
  className="mx-auto"
  style={{ width:"62%" }}
  title="イテレーションノード"
/>

1. 情報統合ノードの後に、イテレーションノードを追加します。
2. イテレーションノード内に、LLMノードを追加して設定します：
   1. `スタイル識別`に名前を変更します。
   2. モデルを選択します。
   3. システムプロンプトフィールドに、以下を貼り付けます：

      <Warning>
        プロンプトで、_役割とタスク_と_出力形式の例_で`Current Iteration/item`変数を参照するには、`{`または`/`を入力してリストから選択します。
      </Warning>
      ````markdown システム {2,40}
      # 役割とタスク
      あなたはソーシャルメディアの専門家です。プラットフォーム「Current Iteration/item」を分析し、コンテンツ作成ガイドラインを提供します。

      # 必要な分析
      与えられたプラットフォームについて、以下を提供：

      ## 1. プラットフォームプロフィール
      - プラットフォームタイプとカテゴリ
      - ターゲットオーディエンスの特性

      ## 2. コンテンツガイドライン
      - 最適なコンテンツ長（文字/単語）
      - 推奨トーン（プロフェッショナル/カジュアル/会話調）
      - フォーマットのベストプラクティス（改行、絵文字など）

      ## 3. エンゲージメント戦略
      - ハッシュタグの推奨事項（数量とスタイル）
      - コール・トゥ・アクションのベストプラクティス
      - アルゴリズム最適化のヒント

      ## 4. 技術仕様
      - 文字/単語制限
      - ビジュアルコンテンツ要件
      - 特別なフォーマットニーズ

      ## 5. プラットフォーム固有の注意事項
      - ユニークな機能または最近の変更
      - 業界固有の考慮事項
      - コミュニティエンゲージメントアプローチ

      # 出力要件
      - 認識されたプラットフォーム：特定のガイドラインを提供
      - 未知のプラットフォーム：類似プラットフォームに基づく推奨事項
      - 実用的で実践的なアドバイスに焦点を当てる
      - 簡潔だが包括的

      # 出力形式の例
      ```json
      {
        "platform_name": "Current Iteration/item",
        "platform_type": "social_media/professional_network/visual_platform/microblogging",
        "content_guidelines": {
          "max_length": "文字/単語制限",
          "optimal_length": "推奨範囲",
          "tone": "プロフェッショナル/カジュアル/会話調/権威的",
          "hashtag_strategy": "数量と配置のガイドライン",
          "formatting": "改行、絵文字、メンションのガイドライン",
          "engagement_focus": "コメント/シェア/いいね/リツイート",
          "call_to_action": "適切なCTAスタイル"
        },
        "special_considerations": "ユニークなプラットフォーム要件または最近の変更",
        "confidence_level": "プラットフォーム認識に基づく高/中/低"
      }
      ````
3. スタイル識別ノードの後に、別のLLMノードを追加して設定します：
   1. `コンテンツ作成`に名前を変更します。
   2. モデルを選択します。
   3. システムプロンプトフィールドに、以下を貼り付けます：

      <Warning>
        プロンプトで、以下の変数を参照するには、`{`または`/`を入力してリストから選択します。
        - _プラットフォームガイドライン_の`Identify Style/text`
        - _ソース情報_の`Integrate Info/text`
        - _ボイス＆トーン（オプション）_の`Start/voice_and_tone`
        - _言語要件_の`Start/language`
      </Warning>
      ```markdown システム {6,9,12,15}
      # 役割とタスク
      あなたは専門的なソーシャルメディアコンテンツクリエーターです。プラットフォームガイドラインに一致し、ソース情報を組み込み、指定されたボイス/トーンと言語要件に従う公開準備完了のコンテンツを生成します。

      # 入力材料
      ## 1. プラットフォームガイドライン
      Identify Style/text

      ## 2. ソース情報
      Integrate Info/text

      ## 3. ボイス＆トーン（オプション）
      Start/voice_and_tone

      ## 4. 言語要件
      - 専用に次の言語ですべてのコンテンツを生成：Start/language
      - 言語を混在させない
      - プラットフォーム用語を指定言語に適応

      # コンテンツ要件
      - プラットフォームガイドラインに正確に従う（形式、長さ、トーン、ハッシュタグ）
      - ソース情報を効果的に統合（キーメッセージ、データ、価値提案）
      - ボイス＆トーンを一貫して適用（提供された場合）
      - プラットフォーム固有のエンゲージメントに最適化
      - 指定言語の文化的適切性を確保

      # 出力形式
      - 最終的なソーシャルメディア投稿コンテンツのみを生成。説明やメタコメントなし。コンテンツはすぐにコピー＆ペースト可能でなければなりません。
      - 最大見出しレベル：##（H2）- #（H1）は決して使用しない
      - 水平区切りなし：---を避ける

      # 品質チェックリスト
      ✅ プラットフォームガイドラインに従った
      ✅ ソース情報を統合した
      ✅ ボイス/トーンが一貫している（提供時）
      ✅ 言語の一貫性を維持
      ✅ エンゲージメントを最適化
      ✅ 公開準備完了
      ```
   4. 構造化出力を有効にします。

      <img
        src="/images/deeper_dive_structured_output.png"
        alt="構造化出力"
        title="構造化出力"
        className="mx-auto"
        style={{ width:"64%" }}
      />
      1. **出力変数**の横で、**構造化**をオンに切り替えます。structured_output変数が下に表示されます。
      2. **structured_output**の横で、**設定**をクリックします。
      3. ポップアップスキーマエディタで、右上隅の**JSONからインポート**をクリックし、以下を貼り付けます：

         ```json
         {
           "platform_name": "string",
           "post_content": "string"
         }
         ```
4. イテレーションノードをクリックして設定します：
   1. `Parameter Extractor/platform`を入力変数として設定します。
   2. `Create Content/structured_output`を出力変数として設定します。
   3. **並列モード**を有効にし、最大並列性を`10`に設定します。

      <Check>
        これが、スタートノードのターゲットプラットフォームフィールドのラベル名に`(≤10)`を含めた理由です。
      </Check>

### 8. テンプレートノード：最終出力をフォーマット

<Info>
  イテレーションノードは各プラットフォーム用の投稿を生成しますが、その出力は生のデータ配列（例：`[{"platform_name": "Twitter", "post_content": "..."}]`）であり、あまり読みやすくありません。結果をより明確な形式で提示する必要があります。

  ここでテンプレートノードが登場します—[Jinja2](https://jinja.palletsprojects.com/en/stable/)テンプレートを使用してこの生データを整理されたテキストにフォーマットでき、最終出力がユーザーフレンドリーで理解しやすいことを保証します。
</Info>

<img
  src="/images/deeper_dive_template.png"
  alt="テンプレートノード"
  title="テンプレートノード"
  style={{ width:"49%" }}
  className="mx-auto"
/>

1. イテレーションノードの後に、テンプレートノードを追加します。
2. テンプレートノードのパネルで、`Iteration/output`を入力変数として設定します。
3. 以下のJinja2コードを貼り付けます（**コメントを削除することを忘れずに**）。

   ```
   {% for item in output %}        # 入力配列の各プラットフォーム-コンテンツペアをループ
   # 📱 {{ item.platform_name }}   # 電話絵文字付きのH1見出しとしてプラットフォーム名を表示
   {{ item.post_content }}        # このプラットフォーム用に生成されたコンテンツを表示
                                  # 読みやすさのためプラットフォーム間に空行を追加
   {% endfor %}                   # ループを終了
   ```

   <Tip>
     LLMも出力フォーマットを処理できますが、その出力は一貫性がなく予測不可能な場合があります。推論を必要としないルールベースのフォーマットについては、テンプレートノードがゼロトークンコストでより安定した信頼性の高い方法で処理します。

     LLMは非常に強力ですが、適切なツールを使用するタイミングを知ることが、より信頼性が高くコスト効果の高いAIアプリケーションを構築する鍵です。
   </Tip>

### 9. 終了ノード：結果をユーザーに返す

1. テンプレートノードの後に、終了ノードを追加します。
2. 終了ノードのパネルで、`Template/output`を出力変数として設定します。

## ステップ3：テスト

ワークフローが完成しました！テストしてみましょう。

1. チェックリストがクリアされていることを確認します。

   <img
     src="/images/deeper_dive_checklist_clear.png"
     alt="チェックリストを確認"
     className="mx-auto"
     style={{ width:"77%" }}
     title="チェックリストを確認"
   />
2. 最初に提供された参照図と照らし合わせてワークフローを確認し、すべてのノードと接続が一致していることを確認します。
3. 右上隅の**実行**をクリックし、入力フィールドを入力して、**実行開始**をクリックします。

   キャッシュされた入力で単一のノードを実行するには、その設定パネルの上部にある**このステップを実行**アイコンをクリックします。

   <Tip>
     前のノードからの異なる入力に対するノードの反応をテストするには、ワークフロー全体を再実行する必要はありません。キャンバスの下部にある**キャッシュされた変数を表示**をクリックし、リストから変更したい変数を見つけて、その値を編集するだけです。
   </Tip>
   エラーが発生した場合は、対応するノードの**最後の実行**ログをチェックして、問題の正確な原因を特定します。

## ステップ4：公開と共有

ワークフローが期待通りに実行され、結果に満足したら、**公開** \> **更新を公開**をクリックして、ライブで共有可能にします。

<Warning>
  後で変更を加えた場合は、更新が有効になるように必ず再度公開することを忘れないでください。
</Warning>

<Tip>
  公開後、ライブ環境でクイックなエンドツーエンドテストを実行して、すべてが**Studio**と同じように動作することを確認できます。
</Tip>
