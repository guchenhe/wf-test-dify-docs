---
title: コード実行
version: '日本語'
---

## 紹介

コードノードを使用すると、カスタムのPythonまたはJavascriptスクリプトをワークフローに埋め込み、組み込みノードでは実現できない方法で変数を操作できます。コードノードは、算術、JSON変換、テキスト処理などのシナリオに適しており、ワークフローを簡素化できます。

コードノードで他のノードの変数を使用するには、まず`入力変数`でその変数を選択してから、コード内で参照する必要があります。

<img
  src="https://assets-docs.dify.ai/dify-enterprise-mintlify/en/guides/workflow/node/9969aa1bc1912aebe366f5d8f5dde296.png"
  width="400"
/>

## 使用シナリオ

コードノードを使用することで、構造化データの処理、数学計算、データの連結などの操作を実現できます。

### 構造化データ処理

ワークフローでは、JSON文字列の解析、抽出、変換など、非構造化データを頻繁に処理する必要があります。最も典型的な例は、HTTPノードのデータ処理です。一般的なAPIの戻り値の構造では、データが複数階層のJSONオブジェクトにネストされている可能性があり、その中から特定のフィールドを抽出する必要があります。コードノードは、これらの操作を完了するのに役立ちます。

例えば、以下のコードを使用して、HTTPノードから返されたJSON文字列から `data.name` フィールドを抽出できます。

```python
def main(http_response: str) -> dict:
    import json
    data = json.loads(http_response)
    return {
        # 出力変数にresultを宣言することに注意
        'result': data['data']['name'] 
    }
```

### 数学計算

ワークフローで複雑な数学計算（複雑な数式の計算やデータの統計分析など）が必要な場合も、コードノードを使用できます。

例えば、次のコードを使用して、配列の二乗和を計算できます。

```python
def main(x: list) -> dict:
    return {
        # 出力変数にresultを宣言することに注意
        'result' : sum([(i - sum(x) / len(x)) ** 2 for i in x]) / len(x)
    }
```

### データの結合

複数のデータソース（複数のナレッジ検索、データ検索、API呼び出しなど）を連結する必要がある場合、コードノードを使用してこれらのデータソースを統合できます。

例えば、次のコードを使用して、2つのナレッジベースのデータを統合できます。

```python
def main(knowledge1: list, knowledge2: list) -> dict:
    return {
        # 出力変数にresultを宣言することに注意
        'result': knowledge1 + knowledge2
    }
```

## ローカルデプロイ

ローカル環境にデプロイしているユーザーの場合、悪意のあるコードが実行されないようにサンドボックスサービス（Sandbox）を起動する必要があります。

サンドボックスサービスの起動にはDockerが必要です。docker-compose を使用して直接サービスを起動できます。

```bash
docker-compose -f docker-compose.middleware.yaml up -d
```

<Note> 
お使いのシステムに Docker Compose V2 がインストールされている場合は、`docker-compose` の代わりに `docker compose` を使用してください。バージョン情報は `$ docker compose version` で確認できます。
詳細については、[Docker 公式ドキュメント](https://docs.docker.com/compose/#compose-v2-and-the-new-docker-compose-command) をお読みください。
</Note>

<Tip> 
サンドボックスサービスの詳細については、[こちら](https://github.com/langgenius/dify/tree/main/docker/docker-compose.middleware.yaml) をご覧ください。 
</Tip>

## セキュリティポリシー

Python3とJavascriptのいずれであっても、その実行環境は安全性を確保するために厳密に隔離（サンドボックス化）されています。これにより、ファイルシステムへの直接アクセス、ネットワークリクエストの実行、OSレベルのコマンドの実行など、システムリソースを大量に消費する可能性がある機能を使用することはできません。これらの制限により、コードの安全な実行が保証され、システムリソースの過剰消費が防止されます。

### 高度な機能

#### エラーリトライ

ノードで発生する一部の例外的な状況については、通常、ノードを再実行することで解決できます。エラーリトライ機能を有効にすると、ノードはエラー発生時に事前に設定されたポリシーに従って自動的にリトライします。

最大リトライ回数と各リトライの間隔を調整できます。

- 最大リトライ回数は10回です
- 最大リトライ間隔は5000msです

![](https://assets-docs.dify.ai/2024/12/9fdd5525a91dc925b79b89272893becf.png)

#### 例外処理

コードノードが情報を処理する際に、コードの実行例外が発生する可能性があります。以下の手順に従って例外分岐を設定することで、ノードで例外が発生した際に代替案を有効にし、プロセス全体の中断を避けることができます。

1. コードノードで **例外処理** を有効にします。
2. 例外処理のプランを選択し、設定します。

![Code Error Handling](https://assets-docs.dify.ai/2024/12/58f392734ce44b22cd8c160faf28cd14.png)

<Tip>
例外処理の方法についてさらに詳しく知りたい場合は、[例外処理](/ja-jp/guides/workflow/error-handling/README) をお読みください。 
</Tip>

### よくある質問

**コード ノードにコードを入力した後にコードを保存できないのはなぜですか?**

コードに危険な動作が含まれていないか確認してください。例：

```python
def main() -> dict:
    return {
        "result": open("/etc/passwd").read(),
    }
```

このコードには次の問題が含まれています。

- **不正なファイル アクセス**: コードは、ユーザー アカウント情報を保存する Unix/Linux システムの重要なシステム ファイルである`/etc/passwd`ファイルを読み取ろうとしました。
- **機密情報の漏洩**: `/etc/passwd`ファイルには、ユーザー名、ユーザー ID、グループ ID、ホーム ディレクトリのパスなど、システム ユーザーの重要な情報が含まれています。直接アクセスすると情報が漏洩する可能性があります。

危険なコードはCloudflare WAFによって自動的にブロックされます。ブロックされているかどうかは、「Webデバッグツール」の「ネットワーク」から確認できます。

![Cloudflare WAF](https://assets-docs.dify.ai/2024/12/ad4dc065c4c567c150ab7fa7bfd123a3.png)

## コード修正

前回実行時の `current_code` と `error_message` 変数を利用して、自動でコードを修正することができます。

コードノードの実行が失敗した場合：

- システムはコードとエラーメッセージをキャプチャします。
- これらの情報はコンテキスト変数としてプロンプトに渡されます。
- システムはレビューと再試行のために新しいバージョンのコードを生成します。

### 修正プロンプト

次のように、修正用のプロンプトをカスタマイズできます。

```
以下のエラーメッセージに基づいてコードを修正してください：

コード：
{{current_code}}

エラー：
{{error_message}}
```

<Info>
プロンプトエディタで、変数挿入メニュー（`/`または`{`）を使用して変数を挿入します。
</Info>

![Codefix](/images/codefix.PNG)

### コンテキスト変数

自動コード修正を有効にするには、プロンプトで以下のコンテキスト変数を参照してください。

- `current_code`：このノードで前回実行されたコード。
- `error_message`：前回の実行が失敗した場合はエラーメッセージ、成功した場合は空になります。

コードノードが実行されると、これらの変数は自動的に利用可能になり、大規模言語モデルが前回の実行情報を使用してコードを修正できるようになります。

<Info>
    - `last_run` 変数は、前回の入力/出力を参照するために使用できます。 
    - 上記の変数に加えて、必要に応じて任意の前段ノードの出力変数を参照することもできます。
</Info>

### バージョン管理

バージョン管理により、手動でのコピー＆ペースト作業が減り、ワークフロー内で直接コードを繰り返しデバッグできるようになります。

- 修正が試みられるたびに、個別のバージョンとして保存されます（例：バージョン1、バージョン2）。
- 結果表示エリアのドロップダウンメニューから、異なるバージョンを切り替えることができます。